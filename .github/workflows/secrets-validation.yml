name: Secrets Validation

on:
  push:
    branches: [ main, feature/* ]
  pull_request:
    branches: [ main ]

jobs:
  secrets_check:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Ensure secrets are not committed
        run: |
          set -e
          echo "Checking for accidentally committed secret files..."
          # These files must NEVER exist in the repo
          forbidden_files=(
            "include/secrets.h"
            "**/secrets.h"
            "*.key" "*.pem" "*.crt"
            ".env" ".env.local"
          )
          for pattern in "${forbidden_files[@]}"; do
            if git ls-files -- "$pattern" | grep -q .; then
              echo "❌ Forbidden file committed: $pattern"
              git ls-files -- "$pattern"
              exit 1
            fi
          done
          echo "✅ No forbidden secret files tracked by git"

      - name: Scan repository for high-risk tokens
        run: |
          set -e
          echo "Scanning for potential secrets in tracked files..."
          patterns=(
            "INFLUXDB_TOKEN" "MQTT_PASSWORD" "MQTT_USER"
            "GRAFANA_API_KEY" "GRAFANA_ADMIN_API_KEY"
            "AWS_SECRET_ACCESS_KEY" "AWS_ACCESS_KEY_ID"
            "Authorization: Bearer" "api_key" "API_KEY" "TOKEN="
          )
          found=0
          for p in "${patterns[@]}"; do
            if git grep -n "$p" -- ':!**/.github/**' ':!**/docs/**' | grep -q .; then
              echo "Potential secret reference found for pattern: $p"
              git grep -n "$p" -- ':!**/.github/**' ':!**/docs/**'
              found=1
            fi
          done
          if [ "$found" -eq 1 ]; then
            echo "⚠️  Review above findings; ensure values come from templates or are placeholders."
          else
            echo "✅ No suspicious secret patterns found in tracked code"
          fi

      - name: Verify .gitignore protects secrets
        run: |
          set -e
          if [ -f .gitignore ]; then
            if grep -qE "(^|/)include/secrets\.h$" .gitignore && grep -q "**/secrets.h" .gitignore; then
              echo "✅ .gitignore includes secrets patterns"
            else
              echo "❌ .gitignore missing secrets ignore rules"
              exit 1
            fi
          fi

      - name: Validate secrets template consistency
        run: |
          set -e
          echo "Checking that example secrets templates exist..."
          templates=(
            "temperature-sensor/include/secrets.h.example"
            "surveillance/include/secrets.h.example"
            "solar-monitor/include/secrets.h.example"
          )
          missing=0
          for t in "${templates[@]}"; do
            if [ ! -f "$t" ]; then
              echo "❌ Missing secrets template: $t"
              missing=1
            else
              echo "✅ Found secrets template: $t"
            fi
          done
          if [ "$missing" -eq 1 ]; then
            exit 1
          fi

      - name: Fail on accidental plaintext tokens
        run: |
          set -e
          echo "Ensuring no obvious plaintext tokens are present..."
          # Allow-list files with documentation that mention tokens
          allow_docs_paths=$(printf ":(exclude)docs/" && printf " :(exclude)README.md")
          # Basic heuristic: looks for long base64-like strings with token keywords
          if git grep -nE "(token|apikey|secret)[^\n]{0,40}[A-Za-z0-9+/]{32,}" -- \
             ':!**/.github/**' ':!**/docs/**' | grep -q .; then
            echo "❌ Possible plaintext tokens detected"
            git grep -nE "(token|apikey|secret)[^\n]{0,40}[A-Za-z0-9+/]{32,}" -- \
             ':!**/.github/**' ':!**/docs/**'
            exit 1
          else
            echo "✅ No plaintext tokens detected"
          fi
